[
  {
    "id": "1-1",
    "chapter": 1,
    "qnum": 1,
    "thoughtTitle": "① 人は運用をミスる",
    "stem": "Webサービスの障害対応を人手に頼りたくない。最もAWSの思想に沿った運用はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "障害時に担当者へ電話し、手順書に従って復旧する"
      },
      {
        "key": "B",
        "text": "障害時にチャットで周知し、担当者が手動でスケールアウトする"
      },
      {
        "key": "C",
        "text": "CloudWatchアラームを起点に自動復旧（例：Auto Scaling/自動再起動）する"
      },
      {
        "key": "D",
        "text": "障害が起きないように高性能なEC2を1台に集約する"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想①は『人は運用をミスる』が前提。検知→判断→対応を人に任せず、監視と復旧を自動化する設計が本質。",
    "required": 1,
    "multi": false
  },
  {
    "id": "1-2",
    "chapter": 1,
    "qnum": 2,
    "thoughtTitle": "① 人は運用をミスる",
    "stem": "毎日決まった時間に処理を実行してレポートをS3へ保存したい。人的ミスを減らす構成として最も適切なのはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "担当者が毎日PCから手動で実行する"
      },
      {
        "key": "B",
        "text": "EC2にcronを設定し、担当者が定期的に結果を確認する"
      },
      {
        "key": "C",
        "text": "EventBridgeでスケジュール起動し、Lambdaで処理する"
      },
      {
        "key": "D",
        "text": "S3に保存したら後でまとめて処理する"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想①の要点は“手作業を前提にしない”。スケジュール実行はEventBridge＋Lambda等で自動化すると人的ミスが減る。",
    "required": 1,
    "multi": false
  },
  {
    "id": "2-1",
    "chapter": 2,
    "qnum": 1,
    "thoughtTitle": "② 人に鍵を持たせるな",
    "stem": "EC2からS3へアクセスさせたい。長期的なアクセスキー管理を避ける最も適切な方法はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "IAMユーザーを作成しアクセスキーをEC2に保存する"
      },
      {
        "key": "B",
        "text": "アクセスキーを環境変数に設定して利用する"
      },
      {
        "key": "C",
        "text": "IAMロールをEC2に付与し、一時認証情報でアクセスする"
      },
      {
        "key": "D",
        "text": "S3のバケットをパブリックにしてアクセスする"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想②は“恒久鍵を配らない”。EC2にはIAMロールを付与し、STS由来の一時認証情報でアクセスさせるのが基本。",
    "required": 1,
    "multi": false
  },
  {
    "id": "2-2",
    "chapter": 2,
    "qnum": 2,
    "thoughtTitle": "② 人に鍵を持たせるな",
    "stem": "社内メンバーがAWS管理コンソールへ安全にログインしたい。各人にIAMユーザーを量産せず、認証を一元化したい。最も適切なのはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "全員でrootアカウントを共有し、MFAだけ付ける"
      },
      {
        "key": "B",
        "text": "全員分のIAMユーザーを作成し、パスワードを配布する"
      },
      {
        "key": "C",
        "text": "IAM Identity CenterでSSOを構成し、権限はロールで付与する"
      },
      {
        "key": "D",
        "text": "アクセスキーを配布してCLIだけ使わせる"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想②では“人に恒久的な鍵を持たせない”。人のログインはIAM Identity Center（SSO）で一元化し、権限はロールで付与するのが安全。",
    "required": 1,
    "multi": false
  },
  {
    "id": "3-1",
    "chapter": 3,
    "qnum": 1,
    "thoughtTitle": "③ 障害は起きる前提で設計せよ",
    "stem": "Webサービスの可用性を高めたい。AWSの考え方に最も沿った設計はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "高性能なEC2を1台用意する"
      },
      {
        "key": "B",
        "text": "障害発生時の運用手順書を作成する"
      },
      {
        "key": "C",
        "text": "複数AZに分散し、自動的に切り替わる構成にする"
      },
      {
        "key": "D",
        "text": "定期的にバックアップを取得する"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "AWSでは障害は必ず起きる前提で設計する。人が判断して復旧する運用は遅く、ミスも入りやすい。\n複数AZ＋自動切替（例：ELB）により、壊れても継続できる構造を作るのが本質。",
    "required": 1,
    "multi": false
  },
  {
    "id": "3-2",
    "chapter": 3,
    "qnum": 2,
    "thoughtTitle": "③ 障害は起きる前提で設計せよ",
    "stem": "次のうち、可用性を高める設計として不適切な考え方はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "障害を前提に設計する"
      },
      {
        "key": "B",
        "text": "冗長構成を採用する"
      },
      {
        "key": "C",
        "text": "自動的に切り替わる仕組みを用意する"
      },
      {
        "key": "D",
        "text": "サーバを強化すれば障害は起きないと考える"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "「強い1台」に寄せるほど単一障害点（SPOF）になりやすい。性能強化ではなく、壊れても続く構造（冗長化＋自動切替）が本質。",
    "required": 1,
    "multi": false
  },
  {
    "id": "4-1",
    "chapter": 4,
    "qnum": 1,
    "thoughtTitle": "④ 証拠が残らない運用は犯罪と同じ",
    "stem": "AWS環境での操作履歴を長期的に追跡・監査したい。最も適切なサービスはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "CloudWatch"
      },
      {
        "key": "B",
        "text": "CloudTrail"
      },
      {
        "key": "C",
        "text": "IAM"
      },
      {
        "key": "D",
        "text": "AWS Config"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "CloudTrailはAWS API操作の証跡（誰が・いつ・何をしたか）を記録する。監査・事故対応・内部不正対策の中核になる。",
    "required": 1,
    "multi": false
  },
  {
    "id": "4-2",
    "chapter": 4,
    "qnum": 2,
    "thoughtTitle": "④ 証拠が残らない運用は犯罪と同じ",
    "stem": "次のうち、証跡（ログ）に関する考え方として不適切なものはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "すべての操作はログとして残す"
      },
      {
        "key": "B",
        "text": "設定変更の履歴を追跡できるようにする"
      },
      {
        "key": "C",
        "text": "問題が起きたら原因をログから調査する"
      },
      {
        "key": "D",
        "text": "信頼できる管理者だけが作業するので記録は不要"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "「信頼できる人がやった」は証拠にならない。人を信じる前提を置かず、必ず記録を残し、後から検証できる状態にする。",
    "required": 1,
    "multi": false
  },
  {
    "id": "5-1",
    "chapter": 5,
    "qnum": 1,
    "thoughtTitle": "⑤ スケールは人間に任せるな",
    "stem": "アクセスが急増する可能性があるWebアプリを運用する。AWSの思想⑤に最も沿った設計はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "ピークに合わせて常に大きなEC2を1台稼働させる"
      },
      {
        "key": "B",
        "text": "負荷が上がったら運用担当が手動で台数を増やす"
      },
      {
        "key": "C",
        "text": "Auto Scalingで負荷に応じて自動で台数を増減させる"
      },
      {
        "key": "D",
        "text": "障害時の復旧手順書を整備して対応する"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "需要予測は外れる前提。人間が都度判断して増減すると遅れ・ミスが発生する。\nAuto Scaling（またはサーバレス等）で「自動で増える／減る」仕組みを先に作るのがAWSの思想⑤。",
    "required": 1,
    "multi": false
  },
  {
    "id": "5-2",
    "chapter": 5,
    "qnum": 2,
    "thoughtTitle": "⑤ スケールは人間に任せるな",
    "stem": "次のうち、思想⑤（自動スケール）に反している考え方はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "CPU使用率などのメトリクスに連動して自動で増減させる"
      },
      {
        "key": "B",
        "text": "突発的なスパイクにも耐えられるよう自動化する"
      },
      {
        "key": "C",
        "text": "需要の増減に合わせてスケールイン（縮小）も自動で行う"
      },
      {
        "key": "D",
        "text": "ピーク時を想定して最初から最大構成で固定運用する"
      }
    ],
    "answer": [
      "D"
    ],
    "explanation": "「最初から最大で固定」はコスト増にもなり、需要変化に追従できない。\nAWSの発想は“読めない”を前提に、スケールアウト/インを自動で回すこと。",
    "required": 1,
    "multi": false
  },
  {
    "id": "6-1",
    "chapter": 6,
    "qnum": 1,
    "thoughtTitle": "⑥ サーバー管理は本質ではない",
    "stem": "スタートアップが Web API を短期間で立ち上げたい。OSパッチ適用や冗長化対応に人手を割きたくない。最も適切な構成はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "EC2（Amazon Linux）＋手動パッチ"
      },
      {
        "key": "B",
        "text": "EC2＋Auto Scaling＋ALB"
      },
      {
        "key": "C",
        "text": "Lambda＋API Gateway"
      },
      {
        "key": "D",
        "text": "EC2＋Docker＋cron"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想⑥では、OS管理や冗長化運用を人が抱える設計を避ける。Lambda＋API Gatewayはサーバ管理が不要。",
    "required": 1,
    "multi": false
  },
  {
    "id": "6-2",
    "chapter": 6,
    "qnum": 2,
    "thoughtTitle": "⑥ サーバー管理は本質ではない",
    "stem": "RDS を利用する主なメリットとして最も適切でないものはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "OS管理が不要"
      },
      {
        "key": "B",
        "text": "バックアップの自動化"
      },
      {
        "key": "C",
        "text": "アプリケーションのバグ修正をAWSが行う"
      },
      {
        "key": "D",
        "text": "Multi-AZによる高可用性"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "RDSはマネージドだが、アプリケーションの責任は利用者側にある（責任共有モデル）。",
    "required": 1,
    "multi": false
  },
  {
    "id": "6-3",
    "chapter": 6,
    "qnum": 3,
    "thoughtTitle": "⑥ サーバー管理は本質ではない",
    "stem": "次のうち、思想⑥に最も反する設計はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "DynamoDBを使いサーバレス化"
      },
      {
        "key": "B",
        "text": "Lambdaでイベント駆動処理"
      },
      {
        "key": "C",
        "text": "EC2にDB・API・バッチを集約"
      },
      {
        "key": "D",
        "text": "Fargateでコンテナ運用"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "1台のEC2に責務を集約すると、管理負荷と障害影響が最大化する。",
    "required": 1,
    "multi": false
  },
  {
    "id": "7-1",
    "chapter": 7,
    "qnum": 1,
    "thoughtTitle": "⑦ データは消える前提で守れ",
    "stem": "RDS を利用している。自動バックアップを有効化しているため、データ保護は十分だと考えている。この考え方の弱点として最も適切なものはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "バックアップ保存期間が1日以上にできない"
      },
      {
        "key": "B",
        "text": "復元テスト（リストア）が行われていない可能性がある"
      },
      {
        "key": "C",
        "text": "Multi-AZ を設定すると自動バックアップが無効になる"
      },
      {
        "key": "D",
        "text": "暗号化を有効化するとバックアップが取得できない"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "思想⑦のポイントは『バックアップは取るだけでは不十分。実際に復元できることを確認して初めて価値になる』。",
    "required": 1,
    "multi": false
  },
  {
    "id": "7-2",
    "chapter": 7,
    "qnum": 2,
    "thoughtTitle": "⑦ データは消える前提で守れ",
    "stem": "S3 に重要データを保存している。リージョン障害レベルの災害も想定して耐性を高めたい。最も適切な構成はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "S3 標準ストレージに保存する"
      },
      {
        "key": "B",
        "text": "S3 バージョニングのみを有効化する"
      },
      {
        "key": "C",
        "text": "Cross-Region Replication（CRR）を設定する"
      },
      {
        "key": "D",
        "text": "S3 へのアップロードをマルチパートにする"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想⑦では『消える前提』で守る。リージョン障害を想定するなら別リージョンへ複製する CRR が有効。",
    "required": 1,
    "multi": false
  },
  {
    "id": "7-3",
    "chapter": 7,
    "qnum": 3,
    "thoughtTitle": "⑦ データは消える前提で守れ",
    "stem": "EBS スナップショットを取得しているが、保管先リージョンは同一のままで運用している。最も懸念すべき点はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "スナップショットは1つしか作成できない"
      },
      {
        "key": "B",
        "text": "スナップショットは増分であり復元できない"
      },
      {
        "key": "C",
        "text": "同一リージョン障害時にスナップショットへアクセスできない可能性がある"
      },
      {
        "key": "D",
        "text": "スナップショットは暗号化できない"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想⑦は『データは消える前提』。同一リージョンに依存すると、リージョン障害でバックアップごと使えないリスクが残る。",
    "required": 1,
    "multi": false
  },
  {
    "id": "8-1",
    "chapter": 8,
    "qnum": 1,
    "thoughtTitle": "⑧ ネットワークは信用するな",
    "stem": "VPC 内の EC2 間通信について、最も適切な説明はどれか。",
    "choices": [
      {
        "key": "A",
        "text": "VPC 内は信頼できるため、アプリケーション側の認証・認可は不要である"
      },
      {
        "key": "B",
        "text": "Security Group があるため、通信は自動的に暗号化される"
      },
      {
        "key": "C",
        "text": "内部通信であっても最小権限の通信制御（Security Group 等）が重要である"
      },
      {
        "key": "D",
        "text": "NACL が設定されていれば Security Group は不要である"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想⑧は『内部=安全は幻想』。侵入済み前提で、内部通信でも最小権限の制御を行う。",
    "required": 1,
    "multi": false
  },
  {
    "id": "8-2",
    "chapter": 8,
    "qnum": 2,
    "thoughtTitle": "⑧ ネットワークは信用するな",
    "stem": "Security Group と Network ACL（NACL）の違いとして正しいものはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "Security Group はステートレスで、NACL はステートフルである"
      },
      {
        "key": "B",
        "text": "Security Group はインスタンス（ENI）に適用され、NACL はサブネットに適用される"
      },
      {
        "key": "C",
        "text": "NACL は許可ルールしか作れず、拒否ルールは作れない"
      },
      {
        "key": "D",
        "text": "Security Group はサブネット単位に適用される"
      }
    ],
    "answer": [
      "B"
    ],
    "explanation": "Security Group はインスタンス（ENI）に付与するステートフルなフィルタ。NACL はサブネット境界で評価されるステートレスなフィルタ。",
    "required": 1,
    "multi": false
  },
  {
    "id": "8-3",
    "chapter": 8,
    "qnum": 3,
    "thoughtTitle": "⑧ ネットワークは信用するな",
    "stem": "Zero Trust（常に検証する）に近い設計として最も適切なものはどれか。",
    "choices": [
      {
        "key": "A",
        "text": "VPN 接続できた端末は、社内システムへ自由にアクセスできる"
      },
      {
        "key": "B",
        "text": "VPC 内の通信はすべて許可し、境界でのみ防御する"
      },
      {
        "key": "C",
        "text": "IAM の認可 + Security Group の最小許可 + アプリケーション認証を組み合わせる"
      },
      {
        "key": "D",
        "text": "NACL のみで全通信を制御する"
      }
    ],
    "answer": [
      "C"
    ],
    "explanation": "思想⑧では『境界を信じない』。認証（誰か）と認可（何ができるか）を複数レイヤーで検証する設計が Zero Trust に近い。",
    "required": 1,
    "multi": false
  },
  {
    "id": "9-1",
    "chapter": 9,
    "qnum": 1,
    "thoughtTitle": "⑨ 遅延はユーザー体験を殺す",
    "stem": "海外ユーザーからWebアクセスが遅いという苦情が増えている。AWSの思想⑨に最も沿った改善策はどれか。",
    "choices": [
      {"key":"A","text":"EC2のインスタンスタイプを大型化する"},
      {"key":"B","text":"CloudFrontを利用してエッジ配信する"},
      {"key":"C","text":"運用担当者を24時間常駐させる"},
      {"key":"D","text":"回線速度が改善されるのを待つ"}
    ],
    "answer":["B"],
    "explanation":"思想⑨は『距離＝遅延』という物理法則を前提にする。ユーザーに近い場所から配信する設計が本質。",
    "required":1,
    "multi":false
  },
  {
    "id": "9-2",
    "chapter": 9,
    "qnum": 2,
    "thoughtTitle": "⑨ 遅延はユーザー体験を殺す",
    "stem": "レイテンシ対策として不適切な考え方はどれか。",
    "choices": [
      {"key":"A","text":"ユーザーに近いリージョンを選択する"},
      {"key":"B","text":"CloudFrontでキャッシュを活用する"},
      {"key":"C","text":"遅延はネットワークだけの問題と考える"},
      {"key":"D","text":"アプリ設計でも遅延を意識する"}
    ],
    "answer":["C"],
    "explanation":"遅延はインフラだけでなくアプリ設計にも影響する。思想⑨はレイヤー横断で考える。",
    "required":1,
    "multi":false
  },
  {
    "id": "9-3",
    "chapter": 9,
    "qnum": 3,
    "thoughtTitle": "⑨ 遅延はユーザー体験を殺す",
    "stem": "グローバルAPIの初回接続レイテンシを下げる構成として最も適切なのはどれか。",
    "choices": [
      {"key":"A","text":"単一リージョンに高性能EC2を配置する"},
      {"key":"B","text":"Global Acceleratorを利用する"},
      {"key":"C","text":"RDSをMulti-AZ構成にする"},
      {"key":"D","text":"Auto Scalingで台数を増やす"}
    ],
    "answer":["B"],
    "explanation":"Global Acceleratorは最寄りエッジへ誘導し、AWSバックボーンを利用して遅延を削減する。",
    "required":1,
    "multi":false
  },
  {
    "id": "10-1",
    "chapter": 10,
    "qnum": 1,
    "thoughtTitle": "⑩ 料金は技術問題である",
    "stem": "AWS利用料が想定以上に増加している。思想⑩として最も不適切な考え方はどれか。",
    "choices": [
      {"key":"A","text":"Cost Explorerで傾向を把握する"},
      {"key":"B","text":"Budgetsで通知を設定する"},
      {"key":"C","text":"料金は経理部門の問題と考える"},
      {"key":"D","text":"Savings Plansを検討する"}
    ],
    "answer":["C"],
    "explanation":"料金は設計の結果であり、思想⑩では技術者が責任を持つ。",
    "required":1,
    "multi":false
  },
  {
    "id": "10-2",
    "chapter": 10,
    "qnum": 2,
    "thoughtTitle": "⑩ 料金は技術問題である",
    "stem": "コスト最適化の説明として誤っているものはどれか。",
    "choices": [
      {"key":"A","text":"不要なリソースを削除する"},
      {"key":"B","text":"常に最安サービスを選択する"},
      {"key":"C","text":"スケールインも考慮する"},
      {"key":"D","text":"利用状況を可視化する"}
    ],
    "answer":["B"],
    "explanation":"最安＝最適ではない。価値とコストのバランスを設計する。",
    "required":1,
    "multi":false
  },
  {
    "id": "10-3",
    "chapter": 10,
    "qnum": 3,
    "thoughtTitle": "⑩ 料金は技術問題である",
    "stem": "長期間稼働が見込まれるEC2のコストを抑える方法として最も適切なのはどれか。",
    "choices": [
      {"key":"A","text":"オンデマンドを使い続ける"},
      {"key":"B","text":"Savings Plansを利用する"},
      {"key":"C","text":"夜間は手動停止する"},
      {"key":"D","text":"インスタンスタイプを固定する"}
    ],
    "answer":["B"],
    "explanation":"予測可能な利用には割引モデルを適用するのが思想⑩。",
    "required":1,
    "multi":false
  },
  {
    "id": "11-1",
    "chapter": 11,
    "qnum": 1,
    "thoughtTitle": "⑪ 移行は一発では終わらない",
    "stem": "オンプレミスからAWSへの移行方針として最も適切なのはどれか。",
    "choices": [
      {"key":"A","text":"全システムを一夜で移行する"},
      {"key":"B","text":"段階的に移行し検証を繰り返す"},
      {"key":"C","text":"移行後の運用は考慮しない"},
      {"key":"D","text":"移行は一度きりと考える"}
    ],
    "answer":["B"],
    "explanation":"思想⑪では移行は継続的プロセスと捉える。",
    "required":1,
    "multi":false
  },
  {
    "id": "11-2",
    "chapter": 11,
    "qnum": 2,
    "thoughtTitle": "⑪ 移行は一発では終わらない",
    "stem": "移行計画において最もリスクが高い考え方はどれか。",
    "choices": [
      {"key":"A","text":"並行稼働期間を設ける"},
      {"key":"B","text":"ロールバック手順を用意する"},
      {"key":"C","text":"Big Bang方式で切り替える"},
      {"key":"D","text":"段階的にデータ移行する"}
    ],
    "answer":["C"],
    "explanation":"一発切替は失敗時の影響が最大化する。思想⑪が否定する方式。",
    "required":1,
    "multi":false
  },
  {
    "id": "11-3",
    "chapter": 11,
    "qnum": 3,
    "thoughtTitle": "⑪ 移行は一発では終わらない",
    "stem": "大量データを物理的にAWSへ移行する際に適したサービスはどれか。",
    "choices": [
      {"key":"A","text":"DMS"},
      {"key":"B","text":"Snowball"},
      {"key":"C","text":"CloudFront"},
      {"key":"D","text":"SQS"}
    ],
    "answer":["B"],
    "explanation":"ネット転送が現実的でない場合、物理移行が有効。",
    "required":1,
    "multi":false
  },
  {
    "id": "12-1",
    "chapter": 12,
    "qnum": 1,
    "thoughtTitle": "⑫ 可観測性がないシステムは死んでいる",
    "stem": "障害時に原因特定ができない最大の要因はどれか。",
    "choices": [
      {"key":"A","text":"ログが取得されていない"},
      {"key":"B","text":"Auto Scalingが有効"},
      {"key":"C","text":"Multi-AZ構成"},
      {"key":"D","text":"IAMロールを利用している"}
    ],
    "answer":["A"],
    "explanation":"思想⑫は『見えない＝直せない』。",
    "required":1,
    "multi":false
  },
  {
    "id": "12-2",
    "chapter": 12,
    "qnum": 2,
    "thoughtTitle": "⑫ 可観測性がないシステムは死んでいる",
    "stem": "可観測性の説明として誤っているものはどれか。",
    "choices": [
      {"key":"A","text":"メトリクスを収集する"},
      {"key":"B","text":"ログを保存する"},
      {"key":"C","text":"人の経験で障害対応する"},
      {"key":"D","text":"トレースで処理経路を追う"}
    ],
    "answer":["C"],
    "explanation":"人の勘に依存する運用は再現性がなく、思想⑫に反する。",
    "required":1,
    "multi":false
  },
  {
    "id": "12-3",
    "chapter": 12,
    "qnum": 3,
    "thoughtTitle": "⑫ 可観測性がないシステムは死んでいる",
    "stem": "分散システムで処理遅延の原因追跡に最も有効なAWSサービスはどれか。",
    "choices": [
      {"key":"A","text":"CloudWatch Logs"},
      {"key":"B","text":"X-Ray"},
      {"key":"C","text":"S3"},
      {"key":"D","text":"IAM"}
    ],
    "answer":["B"],
    "explanation":"X-Rayはリクエスト単位で処理経路を可視化できる。",
    "required":1,
    "multi":false
  }
]