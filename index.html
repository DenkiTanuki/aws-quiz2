<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="theme-color" content="#070a0f"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="AWS問題集2"/>
<title>AWS 問題集2 v1.0.0</title>
<style>
:root {
  /* Theme variables (default: dark) */
  --bg0:#070a0f; --bg1:#0c121b; --panel:#101a26; --panel2:#0d1620;
  --line:#1a2a3a; --text:#e6eef7; --muted:#a9b6c5; --accent:#4ea1ff; --bad:#ff5a6b; --good:#52d27d;
  --btn:#122235;
  --pagebg: radial-gradient(1200px 800px at 50% -100px,#18283c 0%,var(--bg0) 55%,#000 100%);
  --barbg: rgba(6,10,15,.78);
  --barborder: rgba(255,255,255,.06);
}

/* Light theme */
body[data-theme="light"]{
  --bg0:#f6f7fb; --bg1:#ffffff; --panel:#ffffff; --panel2:#f2f4f8;
  --line:#d8dde6; --text:#121722; --muted:#4a5568;
  --accent:#1d6fff; --bad:#d53a4a; --good:#1f8f52;
  --btn:#eef2f7;
  --pagebg: linear-gradient(180deg,#ffffff 0%,#f4f6fb 55%,#eef1f6 100%);
  --barbg: rgba(255,255,255,.80);
  --barborder: rgba(18,23,34,.12);
}

/* Beige theme */
body[data-theme="beige"]{
  --bg0:#f5f1e8; --bg1:#fffdf8; --panel:#fffdf8; --panel2:#f5efe3;
  --line:#d7cfc1; --text:#1a1a1a; --muted:#5a544a;
  --accent:#2a7de1; --bad:#c83a47; --good:#21824f;
  --btn:#f1eadc;
  --pagebg: linear-gradient(180deg,#fffdf8 0%,#f5f1e8 60%,#efe6d6 100%);
  --barbg: rgba(255,253,248,.82);
  --barborder: rgba(26,26,26,.12);
}

*{box-sizing:border-box}
html{-webkit-text-size-adjust: 100%; text-size-adjust: 100%;}
body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;background:var(--pagebg);color:var(--text); -webkit-text-size-adjust: 100%; text-size-adjust: 100%;}
header{position:sticky;top:0;z-index:10;background:var(--barbg);backdrop-filter: blur(10px);border-bottom:1px solid var(--barborder);}
.topbar{max-width:1200px;margin:0 auto;padding:10px 12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
select,button,input{font:inherit}
.sel{background:var(--panel2);color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px 12px;}
.btn{background:var(--btn);color:var(--text);border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px 14px;cursor:pointer}
.btn:hover{border-color:rgba(255,255,255,.22)}
.btn{ white-space:nowrap; }
.btn:disabled{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.08)}
.btn.primary{background:linear-gradient(180deg,#2f80ff,#1c63d8);border-color:rgba(78,161,255,.35)}

/* Thought badges (思想フィルタ) */
.thoughtbar{max-width:1200px;margin:0 auto;padding:0 12px 10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
.thoughtBtn{padding:7px 12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);color:var(--text);cursor:pointer;font-size:12px;}
.thoughtBtn:hover{border-color:rgba(255,255,255,.22)}
.thoughtBtn.active{background:rgba(78,161,255,.18);border-color:rgba(78,161,255,.35)}
.thoughtBtn.all{color:var(--muted)}
.thoughtHint{font-size:12px;color:var(--muted);margin-left:2px}


/* Collapsible filter panel */
.badge.mini{padding:7px 10px;font-size:12px;max-width:520px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.filterPanel{max-width:1200px;margin:0 auto;padding:0 12px 12px;border-top:1px solid var(--barborder)}
.filterGrid{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end;padding-top:10px}
.filterItem{display:flex;gap:8px;align-items:center}
.filterLabel{font-size:12px;color:var(--muted);min-width:38px}
.filterSubLabel{margin-top:10px;font-size:12px;color:var(--muted)}
/* make the thoughtbar live nicely inside panel */
#filterPanel .thoughtbar{padding:8px 0 0;margin:0;max-width:none}

@media (max-width: 520px){
  .badge.mini{max-width:100%}
  #filterSummary{flex:1 1 100%}
  #filterToggleBtn{flex:0 0 auto}
}

/* Light/Beige themes: make key navigation buttons slightly darker for readability */
body[data-theme="light"] #toggleExplainBtn,
body[data-theme="light"] #prevBtn,
body[data-theme="light"] #nextBtn{
  background: #d6e0e8;
  border-color: rgba(18,23,34,.22);
}
body[data-theme="light"] #toggleExplainBtn:hover,
body[data-theme="light"] #prevBtn:hover,
body[data-theme="light"] #nextBtn:hover{
  border-color: rgba(18,23,34,.32);
}
body[data-theme="beige"] #toggleExplainBtn,
body[data-theme="beige"] #prevBtn,
body[data-theme="beige"] #nextBtn{
  background: #e1d6c6;
  border-color: rgba(26,26,26,.20);
}
body[data-theme="beige"] #toggleExplainBtn:hover,
body[data-theme="beige"] #prevBtn:hover,
body[data-theme="beige"] #nextBtn:hover{
  border-color: rgba(26,26,26,.30);
}
.badge{padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);color:var(--muted);}
.tag{display:inline-block;padding:4px 8px;border-radius:999px;background:rgba(78,161,255,.12);border:1px solid rgba(78,161,255,.22);color:var(--text);font-size:12px;margin-right:6px;margin-top:6px}
.tagRow{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
main{max-width:1200px;margin:0 auto;padding:18px 12px 90px;}
.card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:18px;padding:18px;box-shadow: 0 20px 60px rgba(0,0,0,.35);}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.meta{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
.thoughtLine{margin-top:.6rem;color:var(--muted);font-size:.92rem;line-height:1.4;display:none;}

.stem{font-size:18px;line-height:1.65;margin:10px 0 14px;white-space:pre-wrap}
.choice{display:flex;gap:12px;align-items:flex-start;background:rgba(0,0,0,.14);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px 14px;margin:10px 0}
.choice:hover{border-color:rgba(255,255,255,.18)}
.choice .k{min-width:28px;height:28px;border-radius:10px;background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:center;color:var(--muted);font-weight:700}
.choice .t{line-height:1.55;white-space:pre-wrap}
.sep{height:1px;background:rgba(255,255,255,.08);margin:14px 0}
.footerbar{position:fixed;left:0;right:0;bottom:0;background:var(--barbg);backdrop-filter: blur(10px);border-top:1px solid var(--barborder);}
.footerbar .inner{max-width:1200px;margin:0 auto;padding:10px 12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between}
.small{font-size:12px;color:var(--muted)}
.panel{border:1px solid rgba(255,255,255,.10);border-radius:16px;padding:12px 14px;background:rgba(0,0,0,.18);white-space:pre-wrap}
.panel.good{border-color:rgba(82,210,125,.35)}
.panel.bad{border-color:rgba(255,90,107,.35)}
.hidden{display:none !important}
kbd{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:8px;padding:2px 6px;font-size:12px}
/* Modal */
.modalMask{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:12px;z-index:50}
body[data-theme="light"] .modalMask{background:rgba(0,0,0,.28)}
body[data-theme="beige"] .modalMask{background:rgba(0,0,0,.28)}
/* v1.0.1b: modal default size a bit smaller (PC) + never exceed viewport */
.modal{width:min(840px,calc(100vw - 24px));max-height:82vh;max-height:calc(100dvh - 24px);overflow:auto;background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--line);border-radius:18px;padding:14px;box-shadow:0 30px 90px rgba(0,0,0,.6)}
.modal .head{display:flex;gap:10px;align-items:center;justify-content:space-between;position:sticky;top:0;background:var(--panel);background:color-mix(in srgb, var(--panel) 88%, transparent);backdrop-filter: blur(10px);padding:10px;border-radius:14px;border:1px solid var(--line)}
.modal .list{margin-top:10px}
/* ===== Glossary readability tuning ===== */
.modal{color:var(--text);}
.modal .head{border-color:var(--line);}
.modal .list{margin-top:10px;}
.item{padding:10px 12px;margin:8px 0;}
.item .tt{color:var(--text);}
.item .dd{color:rgba(230,238,247,.88);margin-top:4px;line-height:1.45;}
.stem{line-height:1.6;}

/* Glossary add panel: keep visible while scrolling list */
.modal{display:flex;flex-direction:column;}
.modal .list{flex:1; overflow:auto; padding-right:4px;}
.glossAddPanel{position:sticky; top:66px; z-index:5; margin-top:10px; background:var(--panel);background:color-mix(in srgb, var(--panel) 92%, transparent); backdrop-filter: blur(10px);}
.glossAddPanel.isClosed{display:none;}
.glossAddPanel .row{flex-wrap:wrap;}
.glossAddPanel .sel{min-width:180px;}
@media (max-width: 520px){
  .glossAddPanel{top:58px;}
  .glossAddPanel #glossNewTerm{width:100% !important;}
  .glossAddPanel #glossNewDesc{min-width:0 !important;}
  .glossAddPanel #glossNewTags{min-width:0 !important;}
}
.item{padding:12px;border-radius:14px;border:1px solid var(--line);background:var(--panel2);margin:10px 0;cursor:pointer}
.item:hover{border-color:var(--accent);border-color:color-mix(in srgb, var(--accent) 35%, var(--line));}
.item .tt{font-weight:700}
.item .dd{color:var(--muted);margin-top:6px;white-space:pre-wrap}
/* ===== iPhone / small-screen tuning ===== */
:root{
  --safe-b: env(safe-area-inset-bottom);
  --safe-t: env(safe-area-inset-top);
  --safe-l: env(safe-area-inset-left);
  --safe-r: env(safe-area-inset-right);
}
/* iOS: prevent "tap highlight" glare */
*{ -webkit-tap-highlight-color: transparent; }
body{ padding-left: var(--safe-l); padding-right: var(--safe-r); }

main{ padding-bottom: calc(90px + var(--safe-b)); }

/* Bottom bar: avoid Home indicator overlap */
.footerbar{ padding-bottom: var(--safe-b); }
.footerbar .inner{ padding-bottom: calc(10px + var(--safe-b)); }

/* Small screens */
@media (max-width: 520px){
  html{ font-size:14px; } /* 全体を少しだけ縮める */
  header{ padding-top: var(--safe-t); }
  .topbar{ gap:8px; padding:8px 10px; }

  /* iOS zoom対策：inputは16px維持（.selが13pxを上書きしてズームするのを防ぐ） */
  input{ font-size:16px; }
  input.sel{ font-size:16px; }
  .sel,.btn{ font-size:13px; }

  .sel,.btn{ padding:8px 10px; border-radius:12px; }
  .badge{ padding:6px 8px; font-size:12px; }

  .stem{ font-size:14px; line-height:1.7; }
  .choice{ padding:10px 10px; }
  .choice .t{ font-size:14px; }

  /* ラジオ/チェックは少しだけ大きく（押しやすさ維持） */
  .choice input{ width:20px; height:20px; margin-top:2px; }

  /* --- v1.0.1: iPhone top bar layout fixes (prevent badge squish) --- */
  .topbar{ flex-wrap:wrap; overflow:visible; }
  .topbar::-webkit-scrollbar{ display:none; }

  /* 1st row: chapter / mode / theme */
  #chapterSel{ order:1; flex:1 1 32%; min-width:0; }
  #modeSel{ order:2; flex:1 1 32%; min-width:0; }
  #themeSel{ order:3; flex:1 1 32%; min-width:0; }

  /* 2nd row: glossary / history / status */
  #glossBtn{ order:4; }
  #histBtn{ order:5; }
  #statusBadge{ order:6; flex:1 1 auto; lex:1 1 45%; } /* 2列っぽく均等 */

  .card{ padding:14px; }
  .modal{ max-height: calc(85vh - var(--safe-b)); }
}

</style>
</head>
<body>
<header>
  <div class="topbar">
    <button id="filterToggleBtn" class="btn" title="フィルタ・表示設定を開閉">フィルタ・表示設定</button>
    <span id="filterSummary" class="badge mini">-</span>
    <button id="glossBtn" class="btn">用語</button>
    <button id="histBtn" class="btn">履歴</button>
    <span id="statusBadge" class="badge">正解 0（回答済 0） / 0問</span>
  </div>

  <!-- 折りたたみ：フィルタ／表示設定 -->
  <div id="filterPanel" class="filterPanel hidden">
    <div class="filterGrid">
      <div class="filterItem">
        <div class="filterLabel">章</div>
        <select id="chapterSel" class="sel"></select>
      </div>

      <div class="filterItem">
        <div class="filterLabel">出題順</div>
        <select id="modeSel" class="sel">
          <option value="normal">通常</option>
          <option value="random">ランダム</option>
        </select>
      </div>

      <div class="filterItem">
        <div class="filterLabel">テーマ</div>
        <select id="themeSel" class="sel" title="背景テーマ">
          <option value="dark">黒</option>
          <option value="light">白</option>
          <option value="beige">ベージュ</option>
        </select>
      </div>
    </div>

    <div class="filterSubLabel">思想（横断フィルタ）</div>
    <div id="thoughtBar" class="thoughtbar"></div>

    <div class="filterSubLabel">出題フィルタ</div>
    <div class="row" style="gap:10px;flex-wrap:wrap">
      <button id="topBtn" class="btn">先頭へ</button>
      <button id="wrongFilterBtn" class="btn">×だけ（フィルタ）</button>
      <button id="unansweredFilterBtn" class="btn">未回答だけ（フィルタ）</button>
      <button id="clearFilterBtn" class="btn">フィルタ解除</button>
    </div>
    <div class="small" style="margin-top:8px">※ 状態はブラウザに保存（localStorage）</div>
  </div>
</header>

<main>
  <div class="card">
    <div class="meta">
      <span id="qTitle" class="badge">-</span>
      <span id="qType" class="badge">-</span>
      <span id="qState" class="badge">-</span>
      <span id="qThoughtBadge" class="badge hidden">-</span>
    </div>

    <div id="qStem" class="stem">読み込み中...</div>

    <div id="choices"></div>

    <div class="sep"></div>

    <div class="row">
      <button id="judgeBtn" class="btn primary">判定</button>
      <button id="toggleExplainBtn" class="btn">解説を表示</button>
      <button id="prevBtn" class="btn">前へ</button>
      <button id="nextBtn" class="btn">次へ</button>
    </div>


    <div id="resultPanel" class="panel hidden" style="margin-top:12px"></div>
    <div id="answerPanel" class="panel hidden" style="margin-top:12px"></div>

    <div class="small" style="margin-top:10px">
      ショートカット： <kbd>←</kbd>/<kbd>→</kbd> 移動、<kbd>J</kbd> 判定、<kbd>E</kbd> 解説、<kbd>G</kbd> 用語、<kbd>H</kbd> 履歴
    </div>
  </div>
</main>




<!-- ===== Modals ===== -->
<div id="glossMask" class="modalMask" role="dialog" aria-modal="true" aria-label="用語">
  <div class="modal">
    <div class="head">
      <div style="font-weight:700">用語</div>
      <div class="row" style="gap:8px">
        <button id="glossToggleAddBtn" class="btn">追加フォームを隠す</button>
        <button id="glossClose" class="btn">閉じる</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <input id="glossSearch" class="sel" style="flex:1" placeholder="検索（用語/説明/タグ）"/>
    </div>

    <div class="glossAddPanel" style="padding:10px;border:1px solid var(--line);border-radius:14px;margin-top:10px">
      <div class="row" style="gap:10px;align-items:flex-start">
        <input id="glossNewTerm" class="sel" style="flex:1" placeholder="用語（右クリック選択から自動入力も可）"/>
        <input id="glossNewTags" class="sel" style="min-width:180px" placeholder="タグ（例: IAM,EC2）"/>
      </div>
      <div class="row" style="gap:10px;margin-top:10px;align-items:flex-start">
        <input id="glossNewDesc" class="sel" style="flex:1;min-width:220px" placeholder="説明"/>
        <button id="glossAddBtn" class="btn primary">追加</button>
        <button id="glossExportUserBtn" class="btn">ユーザー用語をJSON出力</button>
      </div>

      <div class="tagRow" style="margin-top:10px">
        <span class="tag" id="tagIAM">IAM</span>
        <span class="tag" id="tagEC2">EC2</span>
        <span class="tag" id="tagST">ST</span>
        <span class="tag" id="tagNW">NW</span>
        <span class="tag" id="tagDB">DB</span>
        <span class="tag" id="tagAI">AI</span>
        <span class="tag" id="tagOTHER">OTHER</span>
      </div>
      <div class="small" style="margin-top:6px">※ タグをクリックすると入力欄に追記されます</div>
    </div>

    <div id="glossList" class="list"></div>
  </div>
</div>

<div id="histMask" class="modalMask" role="dialog" aria-modal="true" aria-label="履歴">
  <div class="modal">
    <div class="head">
      <div style="font-weight:700">履歴</div>
      <div class="row" style="gap:8px">
        <button id="histCopyAllBtn" class="btn">全コピー</button>
        <button id="histExportBtn" class="btn">JSON出力</button>
        <button id="histClearBtn" class="btn">履歴クリア</button>
        <button id="histClose" class="btn">閉じる</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px;gap:10px">
      <select id="histFilter" class="sel">
        <option value="all">すべて</option>
        <option value="unanswered">未回答</option>
        <option value="answered">回答済み</option>
        <option value="correct">正解</option>
        <option value="wrong">不正解</option>
      </select>
      <input id="histSearch" class="sel" style="flex:1" placeholder="検索（問題文）"/>
    </div>

    <div id="histList" class="list"></div>
  </div>
</div>

<script>
// --- iOS Safari / private mode safe storage wrapper ---
const _storage = (()=>{
  try {
    const k = "__aws_quiz_test__";
    window.localStorage.setItem(k, "1");
    window.localStorage.removeItem(k);
    return window.localStorage;
  } catch (e) {
    const mem = Object.create(null);
    return {
      getItem: (key) => (key in mem ? mem[key] : null),
      setItem: (key, val) => { mem[key] = String(val); },
      removeItem: (key) => { delete mem[key]; },
    };
  }
})();
const lsGet = (k) => _storage.getItem(k);
const lsSet = (k, v) => _storage.setItem(k, v);
const lsDel = (k) => _storage.removeItem(k);


let QUESTIONS = [];
let GLOSSARY = [];

// 外部JSON専用：同フォルダの questions.json / glossary.json を fetch で読み込みます。
// ※ file:// 直開きだと fetch が失敗することがあります。確実に動かすにはローカルサーバ推奨（例: python -m http.server）
async function loadJson(url){
  const base = new URL(".", location.href);
  const target = new URL(url, base);
  const r = await fetch(target, { cache: "no-store" });
  if(!r.ok) throw new Error(`${url}: HTTP ${r.status}`);
  return await r.json();
}

// --- data fix: infer missing answers from explanation (e.g., "答え‥A、D")
function inferMissingAnswers(){
  const re = /答え\s*[\.．…‥・]*\s*[:：]?\s*([A-EＡ-Ｅ][A-EＡ-Ｅ\s,、・\/]*)(?:\n|$)/;
  for (const q of QUESTIONS){
    if (Array.isArray(q.answer) && q.answer.length > 0) continue;
    const exp = (q.explanation || q.explain || "").trim();
    if (!exp) continue;
    const m = exp.match(re);
    if (!m) continue;
    const letters = (m[1] || "").toUpperCase().match(/[A-E]/g) || [];
    const uniq = Array.from(new Set(letters));
    if (uniq.length === 0) continue;
    q.answer = uniq;
    if (!q.multi && uniq.length > 1) q.multi = true;
    if (!q.required || q.required < 1) q.required = 1;
    if (uniq.length > 1 && q.required === 1) q.required = uniq.length;
  }
}

const LS_KEY = "aws_quiz_attempts_v1";
const LS_GLOSS_USER = "aws_quiz_user_glossary_v1";
const LS_THEME = "aws_quiz_theme_v1";

let attempts = loadAttempts();
let chapterSel = document.getElementById("chapterSel");
let modeSel = document.getElementById("modeSel");
let themeSel = document.getElementById("themeSel");
let statusBadge = document.getElementById("statusBadge");

let filterToggleBtn = document.getElementById("filterToggleBtn");
let filterPanel = document.getElementById("filterPanel");
let filterSummary = document.getElementById("filterSummary");
const LS_FILTER_OPEN = "aws_quiz_filter_open_v1";

let qIndex = 0;
let activeList = [];
let wrongOnly = false;
let unansweredOnly = false;

// 思想フィルタ（バッジUI）
let activeThoughts = new Set(); // Set of normalized thoughtTitle
let thoughtFilterMode = "any"; // "any"(OR) / "all"(AND)  ※現状はanyを使用

let showExplain = false;

function el(id){ return document.getElementById(id); }

function applyTheme(theme){
  const t = (theme === 'light' || theme === 'beige') ? theme : 'dark';
  document.body.setAttribute('data-theme', t);
  const meta = document.querySelector("meta[name='theme-color']");
  if (meta){
    meta.setAttribute('content', t==='light' ? '#ffffff' : (t==='beige' ? '#fffdf8' : '#070a0f'));
  }
  try { lsSet(LS_THEME, t); } catch(e) {}
  if (themeSel) themeSel.value = t;
}



function buildFilterSummaryText(){
  const parts = [];

  // 思想
  if (activeThoughts && activeThoughts.size){
    const arr = Array.from(activeThoughts);
    const short = arr.map(t => (t.length>18 ? t.slice(0,18)+"…" : t));
    parts.push("思想:" + short.join("+"));
  } else {
    parts.push("思想:ALL");
  }

  // 章
  try{
    const ch = parseInt(chapterSel.value,10);
    if (!ch) parts.push("章:全章");
    else parts.push(ch===999 ? "章:独自問題" : `章:第${ch}章`);
  }catch(e){}

  // 出題順
  try{
    const mode = modeSel.value === "random" ? "ランダム" : "通常";
    parts.push("順:" + mode);
  }catch(e){}

  // テーマ
  try{
    const theme = themeSel.value;
    const th = theme==="beige" ? "ベージュ" : (theme==="light" ? "白" : "黒");
    parts.push("色:" + th);
  }catch(e){}

  // 下部フィルタ
  if (wrongOnly) parts.push("×だけ");
  if (unansweredOnly) parts.push("未回答だけ");

  return parts.join("｜");
}

function updateFilterSummary(){
  if (!filterSummary) return;
  filterSummary.textContent = buildFilterSummaryText();
  filterSummary.title = filterSummary.textContent;
}

function setFilterPanelOpen(isOpen){
  if (!filterPanel) return;
  filterPanel.classList.toggle("hidden", !isOpen);
  try { lsSet(LS_FILTER_OPEN, isOpen ? "1" : "0"); } catch(e) {}
}

function initFilterPanel(){
  if (!filterToggleBtn || !filterPanel) return;
  // 初期状態：保存値があればそれを使用
  const open = (lsGet(LS_FILTER_OPEN) ?? "0") === "1";
  setFilterPanelOpen(open);

  if (!filterToggleBtn.dataset.bound){
    filterToggleBtn.dataset.bound = "1";
    filterToggleBtn.addEventListener("click", ()=>{
      const nowOpen = !filterPanel.classList.contains("hidden");
      setFilterPanelOpen(!nowOpen);
    });

    // パネル外クリックで閉じる（ボタン・パネル内は無視）
    document.addEventListener("click",(e)=>{
      if (!filterPanel || filterPanel.classList.contains("hidden")) return;
      const t = e.target;
      if (filterToggleBtn && filterToggleBtn.contains(t)) return;
      if (filterPanel.contains(t)) return;
      setFilterPanelOpen(false);
    });
  }
}

function stripLeak(s) {
  if (!s) return "";
  return s.split(/\n/).filter(line => !/^\s*第\s*\d+\s*章/.test(line.trim())).join("\n").trim();
}

function loadAttempts() {
  try {
    const raw = lsGet(LS_KEY);
    if (!raw) return {};
    return JSON.parse(raw);
  } catch(e) {
    return {};
  }
}
function saveAttempts() {
  try { lsSet(LS_KEY, JSON.stringify(attempts)); } catch(e) {}
}


function normalizeTags(s){
  if (!s) return [];
  return String(s).split(",").map(x=>x.trim()).filter(Boolean).map(x=>x.toUpperCase());
}
function loadUserGlossary(){
  try { return JSON.parse(lsGet(LS_GLOSS_USER) || "[]"); } catch(e){ return []; }
}
function saveUserGlossary(list){
  try { lsSet(LS_GLOSS_USER, JSON.stringify(list||[])); } catch(e) {}
}
function exportUserGlossaryJson(){
  const rows = loadUserGlossary();
  const payload = { exportedAt: new Date().toISOString(), rows };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "aws_user_glossary.json";
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}


function normThoughtTitle(s){
  return (s||"").trim();
}

function getUniqueThoughtTitles(){
  const seen = new Set();
  const out = [];
  for (const q of QUESTIONS){
    const t = normThoughtTitle(q.thoughtTitle || q.thought || "");
    if (!t) continue;
    if (seen.has(t)) continue;
    seen.add(t);
    out.push(t);
  }
  return out;
}

function buildThoughtBar(){
  const bar = document.getElementById("thoughtBar");
  if (!bar) return;
  bar.innerHTML = "";
  const titles = getUniqueThoughtTitles();

  // [ALL] ボタン
  const allBtn = document.createElement("button");
  allBtn.type = "button";
  allBtn.className = "thoughtBtn all" + (activeThoughts.size===0 ? " active" : "");
  allBtn.textContent = "ALL（思想）";
  allBtn.title = "思想フィルタ解除";
  allBtn.addEventListener("click", ()=>{
    activeThoughts = new Set();
    buildThoughtBar();
    qIndex = 0;
    applyMode();
  });
  bar.appendChild(allBtn);

  // 思想ごとのバッジ
  for (const t of titles){
    const b = document.createElement("button");
    b.type = "button";
    const active = activeThoughts.has(t);
    b.className = "thoughtBtn" + (active ? " active" : "");
    // 表示は短く（長い思想タイトルでもUIが崩れにくい）
    b.textContent = t.length > 28 ? (t.slice(0,28) + "…") : t;
    b.title = t;
    b.addEventListener("click", ()=>{
      const key = normThoughtTitle(t);
      if (activeThoughts.has(key)) activeThoughts.delete(key);
      else {
        // OR運用：複数ONを許可（必要ならここで1つだけにする）
        activeThoughts.add(key);
      }
      buildThoughtBar();
      qIndex = 0;
      applyMode();
    });
    bar.appendChild(b);
  }

  // ヒント（小さく）
  const hint = document.createElement("span");
  hint.className = "thoughtHint";
  hint.textContent = "※思想バッジで横断フィルタ";
  bar.appendChild(hint);
}
function buildChapterOptions() {
  const chs = Array.from(new Set(QUESTIONS.map(q=>q.chapter))).sort((a,b)=>a-b);
  chapterSel.innerHTML = "";
  const optAll = document.createElement("option");
  optAll.value = "0"; optAll.textContent = "全章";
  chapterSel.appendChild(optAll);
  for (const ch of chs) {
    const o = document.createElement("option");
    o.value = String(ch);
    o.textContent = (Number(ch)===999) ? "独自問題" : `第${ch}章`;
    chapterSel.appendChild(o);
  }
}

function getBaseList() {
  const ch = parseInt(chapterSel.value,10);
  let base = QUESTIONS.slice();
  if (ch && !isNaN(ch)) base = base.filter(q=>q.chapter===ch);
  base.sort((a,b)=> (a.chapter-b.chapter) || (a.qnum-b.qnum));
  return base;
}

function shuffle(arr) {
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function applyMode() {
  const mode = modeSel.value;
  // 基本リスト（左プルダウン：全章 or 章指定）を取得
  let list = getBaseList();

  // 思想フィルタ（バッジ）
  if (activeThoughts && activeThoughts.size > 0) {
    if (thoughtFilterMode === "all") {
      // 1問に複数思想を持たせる設計になった場合に備えたAND（現状thoughtTitleは1つ想定）
      list = list.filter(q => activeThoughts.has(normThoughtTitle(q.thoughtTitle || q.thought || "")));
    } else {
      // OR（いずれかの思想に一致）
      list = list.filter(q => activeThoughts.has(normThoughtTitle(q.thoughtTitle || q.thought || "")));
    }
  }

  // 並び順（通常 / ランダム）
  if (mode === "random") {
    list = shuffle(list);
  } else {
    // "normal" は getBaseList() が章→問番号でソート済み
  }

  // 下部フィルタ（×だけ / 未回答だけ）
  if (wrongOnly) {
    list = list.filter(q => attempts[q.id] && attempts[q.id].answered && attempts[q.id].correct === false);
  }
  if (unansweredOnly) {
    list = list.filter(q => !attempts[q.id] || !attempts[q.id].answered);
  }

  activeList = list;
  if (qIndex >= activeList.length) qIndex = Math.max(0, activeList.length - 1);
  updateStatus();
  updateFilterSummary();
  render();
}

function updateStatus() {
  const total = activeList.length;
  let answered=0, correct=0;
  for (const q of activeList) {
    const a = attempts[q.id];
    if (a && a.answered) {
      answered++;
      if (a.correct) correct++;
    }
  }
  const rate = answered > 0 ? Math.round((correct / answered) * 100) : 0;
  statusBadge.textContent = `正解 ${correct}（回答済 ${answered} / 正解率 ${rate}%） / ${total}問`;
  updateFilterSummary();
}

function setPanelsHidden() {
  showExplain = false;
  el("answerPanel").classList.add("hidden");
  el("resultPanel").classList.add("hidden");
  el("toggleExplainBtn").textContent = "解説を表示";
}

function updateNavButtons(){
  const prev = el("prevBtn");
  const next = el("nextBtn");
  const has = activeList.length > 0;
  if (!prev || !next) return;
  prev.disabled = (!has || qIndex <= 0);
  next.disabled = (!has || qIndex >= activeList.length - 1);
}



function render() {
  if (!activeList.length) {
    el("qTitle").textContent = "表示対象なし";
    el("qType").textContent = "-";
    el("qState").textContent = "-";
    const qt = el("qThought"); if(qt){ qt.textContent = ""; qt.style.display = "none"; }
    el("qStem").textContent = "表示対象の問題がありません。フィルタを解除するかモードを変更してください。";
    el("choices").innerHTML = "";
    setPanelsHidden();
    updateNavButtons();
    bindGlossRightClick();
    return;
  }
  const q = activeList[qIndex];

  const a = attempts[q.id];
  const answered = a && a.answered;
  const correct = answered ? a.correct : null;

  const chLabel = (Number(q.chapter)===999) ? "独自問題" : `第${q.chapter}章`;
  el("qTitle").textContent = `${chLabel} / 練習問題${q.qnum}`;
  el("qType").textContent = q.multi ? `複数選択（${q.required}つ）` : "単一選択";
  el("qState").textContent = !answered ? "未回答" : (correct ? "○ 正解" : "× 不正解");

  // 思想（章テーマ）をヘッダ付近にバッジとして表示（問題文には出さない）
  const thought = q.thoughtTitle || q.thought || "";
  const tb = el("qThoughtBadge");
  if (tb){
    if (thought){
      tb.textContent = `思想：${thought}`;
      tb.classList.remove("hidden");
    }else{
      tb.textContent = "-";
      tb.classList.add("hidden");
    }
  }

  const qt = el("qThought");
  if (qt){
    if (thought) { qt.textContent = `思想：${thought}`; qt.style.display = ""; }
    else { qt.textContent = ""; qt.style.display = "none"; }
  }


  el("qStem").textContent = stripLeak(q.stem);

  const box = el("choices");
  box.innerHTML = "";
  const selected = (a && Array.isArray(a.selected)) ? a.selected : [];
  for (const c of q.choices) {
    const row = document.createElement("div");
    row.className = "choice";
    const inp = document.createElement("input");
    inp.type = q.multi ? "checkbox" : "radio";
    inp.name = "choice";
    inp.value = c.key;
    inp.checked = selected.includes(c.key);
    inp.addEventListener("change", ()=>onSelect(q, inp.value, inp.checked));
    const k = document.createElement("div");
    k.className = "k";
    k.textContent = c.key;
    const t = document.createElement("div");
    t.className = "t";
    t.textContent = stripLeak(c.text);
    row.appendChild(inp);
    row.appendChild(k);
    row.appendChild(t);
    box.appendChild(row);
  }

  setPanelsHidden();
  updateNavButtons();
  bindGlossRightClick();
}

function onSelect(q, key, checked) {
  let a = attempts[q.id] || {selected:[], answered:false, correct:false};
  let sel = Array.isArray(a.selected) ? a.selected.slice() : [];
  if (q.multi) {
    if (checked) {
      if (!sel.includes(key)) sel.push(key);
    } else {
      sel = sel.filter(x=>x!==key);
    }
  } else {
    sel = [key];
  }
  a.selected = sel;
  attempts[q.id] = a;
  saveAttempts();
}

function judge() {
  if (!activeList.length) return;
  const q = activeList[qIndex];
  const a = attempts[q.id] || {selected:[], answered:false, correct:false};
  const sel = Array.isArray(a.selected) ? a.selected.slice() : [];
  const ans = Array.isArray(q.answer) ? q.answer.slice() : [];
  let ok = false;

  if (!ans.length) {
    ok = false;
  } else {
    const s1 = sel.slice().sort().join(",");
    const s2 = ans.slice().sort().join(",");
    ok = (s1===s2);
  }
  a.answered = true;
  a.correct = ok;
  a.answeredAt = Date.now();
  attempts[q.id] = a;
  saveAttempts();
  updateStatus();

  const panel = el("resultPanel");
  panel.classList.remove("hidden");
  panel.classList.toggle("good", ok);
  panel.classList.toggle("bad", !ok);
  const ansStr = ans.length ? ans.join(",") : "（未登録）";
  panel.textContent = ok ? `○ 正解　あなた: ${sel.join(",") || "（未選択）"} / 正解: ${ansStr}`
                         : `× 不正解　あなた: ${sel.join(",") || "（未選択）"} / 正解: ${ansStr}`;

  el("qState").textContent = ok ? "○ 正解" : "× 不正解";

  // ▼ v1.0.1: after judging, scroll to the answer/result area (mobile-friendly)
  const ap = el("answerPanel");
  const rp = el("resultPanel");
  const target = (ap && !ap.classList.contains("hidden")) ? ap : rp;
  if (target && target.scrollIntoView) {
    target.scrollIntoView({behavior:"smooth", block:"start"});
  }
}

function toggleExplain() {
  if (!activeList.length) return;
  const q = activeList[qIndex];
  showExplain = !showExplain;
  const p = el("answerPanel");

  if (!showExplain) {
    p.classList.add("hidden");
    el("toggleExplainBtn").textContent = "解説を表示";
    return;
  }

  el("toggleExplainBtn").textContent = "解説を隠す";
  p.classList.remove("hidden");
  const ansStr = (q.answer && q.answer.length) ? q.answer.join(",") : "（未登録）";
  const exp = stripLeak(q.explanation || "（解説なし）");
  p.textContent = `正解： ${ansStr}\n\n${exp}`;

  // ▼ v1.0.1: when showing explanation, also scroll to the answer area
  if (p && p.scrollIntoView) {
    p.scrollIntoView({behavior:"smooth", block:"start"});
  }
}
function go(delta) {
  if (!activeList.length) return;
  qIndex = Math.max(0, Math.min(activeList.length-1, qIndex + delta));
  render();
}

// iPhone等で input にフォーカスすると Safari がズーム/レイアウト変更し、モーダルが"巨大化"して見えることがあるため
// スマホ（coarse pointer または狭幅）では自動フォーカスしない。
function shouldAutoFocusInModal(){
  try{
    if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) return false;
    if (window.innerWidth && window.innerWidth <= 520) return false;
  }catch(e){}
  return true;
}

function openGloss() {
  el("glossMask").style.display="flex";
  initGlossAddToggle();
  renderGloss();
  if (shouldAutoFocusInModal()) el("glossSearch").focus();
}
function closeGloss() { el("glossMask").style.display="none"; }
function renderGloss() {
  const q = el("glossSearch").value.trim().toLowerCase();
  const list = el("glossList");
  list.innerHTML="";
  const userGloss = loadUserGlossary();
  const merged = [...GLOSSARY, ...userGloss];
  const items = merged.filter(e=> !q || e.term.toLowerCase().includes(q) || (e.desc||"").toLowerCase().includes(q) || (Array.isArray(e.tags)? e.tags.join(",").toLowerCase().includes(q) : false));
  for (const it of items) {
    const div=document.createElement("div");
    div.className="item";
    const t=document.createElement("div"); t.className="tt"; t.textContent=it.term;
    const d=document.createElement("div"); d.className="dd"; d.textContent=it.desc;
    div.appendChild(t); div.appendChild(d);
    // tags
    if (Array.isArray(it.tags) && it.tags.length){
      const tr = document.createElement("div");
      tr.className = "tagRow";
      for (const tg of it.tags){
        const sp = document.createElement("span");
        sp.className = "tag";
        sp.textContent = tg;
        tr.appendChild(sp);
      }
      div.appendChild(tr);
    }
    list.appendChild(div);
  }
  if (!items.length) {
    const div=document.createElement("div");
    div.className="item";
    div.textContent="該当なし";
    list.appendChild(div);
  }
}

function openHist() {
  el("histMask").style.display="flex";
  renderHist();
  if (shouldAutoFocusInModal()) el("histSearch").focus();
}
function closeHist() { el("histMask").style.display="none"; }
function renderHist() {
  const f = el("histFilter").value;
  const q = el("histSearch").value.trim();
  const list=el("histList");
  list.innerHTML="";
  const items = activeList.filter(qq=> {
    const a=attempts[qq.id];
    const answered=a && a.answered;
    const ok=answered && a.correct===true;
    const ng=answered && a.correct===false;
    if (f==="unanswered" && answered) return false;
    if (f==="wrong" && !ng) return false;
    if (f==="correct" && !ok) return false;
    if (f==="answered" && !answered) return false;
    if (q) {
      const hay = `${qq.chapter}章 練習問題${qq.qnum}\n${qq.stem}`.toLowerCase();
      if (!hay.includes(q.toLowerCase())) return false;
    }
    return true;
  });
  for (const it of items) {
    const a=attempts[it.id];
    const answered=a && a.answered;
    const tag = !answered ? "未回答" : (a.correct ? "○" : "×");
    const div=document.createElement("div");
    div.className="item";
    div.addEventListener("click", ()=>{
      const idx = activeList.findIndex(x=>x.id===it.id);
      if (idx>=0) {
        qIndex=idx;
        closeHist();
        render();
      }
    });
    const t=document.createElement("div"); t.className="tt"; t.textContent=`[${tag}] 第${it.chapter}章 / 練習問題${it.qnum}`;
    const d=document.createElement("div"); d.className="dd"; d.textContent=stripLeak(it.stem).slice(0,160);
    div.appendChild(t); div.appendChild(d);
    list.appendChild(div);
  }
  if (!items.length) {
    const div=document.createElement("div");
    div.className="item";
    div.textContent="該当なし（フィルタ/検索条件を見直してください）";
    list.appendChild(div);
  }
}

// events
chapterSel.addEventListener("change", ()=>{ qIndex=0; applyMode(); });
modeSel.addEventListener("change", ()=>{ qIndex=0; applyMode(); });

el("judgeBtn").addEventListener("click", judge);
el("toggleExplainBtn").addEventListener("click", toggleExplain);
el("prevBtn").addEventListener("click", ()=>go(-1));
el("nextBtn").addEventListener("click", ()=>go(1));
el("topBtn").addEventListener("click", ()=>{ qIndex=0; render(); });

el("wrongFilterBtn").addEventListener("click", ()=>{ wrongOnly=true; unansweredOnly=false; qIndex=0; applyMode(); });
el("unansweredFilterBtn").addEventListener("click", ()=>{ unansweredOnly=true; wrongOnly=false; qIndex=0; applyMode(); });
el("clearFilterBtn").addEventListener("click", ()=>{ wrongOnly=false; unansweredOnly=false; qIndex=0; applyMode(); });

el("glossBtn").addEventListener("click", openGloss);
el("glossClose").addEventListener("click", closeGloss);
el("glossMask").addEventListener("click", (e)=>{ if(e.target.id==="glossMask") closeGloss(); });
el("glossSearch").addEventListener("input", renderGloss);

// --- Glossary: add from UI ---
function appendTagToInput(tag){
  const inp = el("glossNewTags");
  if (!inp) return;
  const tags = normalizeTags(inp.value);
  const t = String(tag||"").toUpperCase();
  if (t && !tags.includes(t)) tags.push(t);
  inp.value = tags.join(",");
}

el("tagIAM")?.addEventListener("click", ()=>appendTagToInput("IAM"));
el("tagEC2")?.addEventListener("click", ()=>appendTagToInput("EC2"));
el("tagST")?.addEventListener("click", ()=>appendTagToInput("ST"));
el("tagNW")?.addEventListener("click", ()=>appendTagToInput("NW"));
el("tagDB")?.addEventListener("click", ()=>appendTagToInput("DB"));
el("tagAI")?.addEventListener("click", ()=>appendTagToInput("AI"));
el("tagOTHER")?.addEventListener("click", ()=>appendTagToInput("OTHER"));

el("glossAddBtn")?.addEventListener("click", ()=>{
  const term = (el("glossNewTerm")?.value || "").trim();
  const desc = (el("glossNewDesc")?.value || "").trim();
  const tags = normalizeTags(el("glossNewTags")?.value || "");
  if (!term || !desc){ alert("用語と説明を入力してください"); return; }

  // 重複チェック（マスター＋ユーザー）
  const user = loadUserGlossary();
  const merged = [...GLOSSARY, ...user];
  if (merged.some(x=> String(x.term).trim() === term)){
    alert("同じ用語が既にあります（マスター/ユーザー含む）");
    return;
  }
  user.push({ term, desc, tags });
  saveUserGlossary(user);
  el("glossNewTerm").value="";
  el("glossNewDesc").value="";
  el("glossNewTags").value="";
  renderGloss();
});

el("glossExportUserBtn")?.addEventListener("click", exportUserGlossaryJson);

// Glossary add form toggle (persist)
const LS_GLOSS_ADD_OPEN = "aws_gloss_add_open_v1";
function setGlossAddOpen(isOpen){
  const panel = document.querySelector(".glossAddPanel");
  const btn = el("glossToggleAddBtn");
  if (!panel || !btn) return;
  panel.classList.toggle("isClosed", !isOpen);
  btn.textContent = isOpen ? "追加フォームを隠す" : "追加フォームを表示";
  try { lsSet(LS_GLOSS_ADD_OPEN, isOpen ? "1" : "0"); } catch(e) {}
}
function initGlossAddToggle(){
  const btn = el("glossToggleAddBtn");
  if (!btn || btn.dataset.bound) return;
  btn.dataset.bound = "1";
  const open = (lsGet(LS_GLOSS_ADD_OPEN) ?? "1") !== "0";
  setGlossAddOpen(open);
  btn.addEventListener("click", ()=>{
    const panel = document.querySelector(".glossAddPanel");
    const nowOpen = panel ? !panel.classList.contains("isClosed") : true;
    setGlossAddOpen(!nowOpen);
  });
}



el("histBtn").addEventListener("click", openHist);
el("histClose").addEventListener("click", closeHist);
// --- History Export / Copy ---
function buildHistoryRows(){
  // attempts: { [qid]: {selected:[], answered:boolean, correct:boolean, answeredAt:number } }
  const rows = [];
  for (const q of QUESTIONS){
    const a = attempts[q.id];
    if (!a) continue;
    rows.push({
      id: q.id,
      chapter: q.chapter,
      qnum: q.qnum,
      question: q.question,
      selected: a.selected || [],
      correct: !!a.correct,
      answered: !!a.answered,
      answeredAt: a.answeredAt || null,
      answer: q.answer || []
    });
  }
  // answeredAt昇順（古い→新しい）
  rows.sort((x,y)=>(x.answeredAt||0)-(y.answeredAt||0));
  return rows;
}

function exportHistoryJson(){
  const payload = {
    exportedAt: new Date().toISOString(),
    totalQuestions: QUESTIONS.length,
    totalAttempts: Object.keys(attempts||{}).length,
    rows: buildHistoryRows()
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "aws_quiz_history.json";
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}

function copyHistoryAll(){
  const rows = buildHistoryRows();
  const lines = [];
  lines.push(`AWS Quiz 履歴エクスポート`);
  lines.push(`exportedAt: ${new Date().toISOString()}`);
  lines.push(`attempts: ${rows.length}`);
  lines.push("");
  for (const r of rows){
    const dt = r.answeredAt ? new Date(r.answeredAt).toLocaleString() : "-";
    const sel = (r.selected||[]).join(",");
    const ans = (r.answer||[]).join(",");
    lines.push(`【第${r.chapter}章 Q${r.qnum}】 ${r.correct ? "○" : "×"}  (${dt})`);
    lines.push(`問題: ${r.question}`);
    lines.push(`選択: ${sel} / 正解: ${ans}`);
    lines.push(`id: ${r.id}`);
    lines.push("");
  }
  const txt = lines.join("\n");
  navigator.clipboard?.writeText(txt).then(()=>{
    alert("履歴を全コピーしました（クリップボード）");
  }).catch(()=>{
    // fallback
    const ta = document.createElement("textarea");
    ta.value = txt;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
    alert("履歴を全コピーしました（クリップボード）");
  });
}


  el("histCopyAllBtn")?.addEventListener("click", copyHistoryAll);
  el("histExportBtn")?.addEventListener("click", exportHistoryJson);
  el("histClearBtn")?.addEventListener("click", () => {
    if(!confirm("履歴をすべて削除します。よろしいですか？")) return;
    lsDel(LS_KEY);
    attempts = {};
    updateStatus();
    renderHist();
    closeHist();
  });
el("histMask").addEventListener("click", (e)=>{ if(e.target.id==="histMask") closeHist(); });
el("histFilter").addEventListener("change", renderHist);
el("histSearch").addEventListener("input", renderHist);


// --- Right-click selection → Glossary add ---
function openGlossWithSelection(){
  const sel = (window.getSelection && window.getSelection().toString()) ? window.getSelection().toString().trim() : "";
  if (!sel) return false;
  openGloss();
  // できるだけ短い語に（長文選択事故防止）
  const term = sel.length > 60 ? sel.slice(0,60) : sel;
  const tEl = el("glossNewTerm");
  if (tEl) tEl.value = term;
  // 既存検索にも反映すると探しやすい
  const sEl = el("glossSearch");
  if (sEl) sEl.value = term;
  renderGloss();
  // スマホでは自動フォーカスを避ける（iOS Safari のズーム/レイアウト変更対策）
  if (shouldAutoFocusInModal()) setTimeout(()=>{ el("glossNewDesc")?.focus(); }, 0);
  return true;
}

function bindGlossRightClick(){
  const targets = [el("qStem"), el("choices")].filter(Boolean);
  for (const t of targets){
    if (t.dataset.rcBound) continue;
    t.dataset.rcBound = "1";
    t.addEventListener("contextmenu", (e)=>{
      // 選択がある時だけ、右クリックを「用語追加」扱いにする
      const ok = openGlossWithSelection();
      if (ok){ e.preventDefault(); }
    });
  }
}

// shortcuts
document.addEventListener("keydown",(e)=>{
  if (e.key==="ArrowRight") { go(1); }
  else if (e.key==="ArrowLeft") { go(-1); }
  else if (e.key.toLowerCase()==="j") { judge(); }
  else if (e.key.toLowerCase()==="e") { toggleExplain(); }
  else if (e.key.toLowerCase()==="g") { openGloss(); }
  else if (e.key.toLowerCase()==="h") { openHist(); }
  else if (e.key==="Escape") {
    if (filterPanel && !filterPanel.classList.contains("hidden")) {
      setFilterPanelOpen(false);
    }
  }
});


async function init() {
  try{
    QUESTIONS = await loadJson("questions.json");
    GLOSSARY  = await loadJson("glossary.json");
  }catch(e){
    console.error(e);
    alert("questions.json / glossary.json の読み込みに失敗しました。\n\n・同じフォルダに配置されているか\n・file://直開きの場合はローカルサーバで開いているか（推奨: python -m http.server）\n\n詳細: " + (e && e.message ? e.message : e));
    // 最低限の表示
    QUESTIONS = [];
    GLOSSARY = [];
  }

  inferMissingAnswers();

  buildChapterOptions();
  buildThoughtBar();
  chapterSel.value = lsGet("aws_quiz_chapter_sel") || "0";
  modeSel.value = lsGet("aws_quiz_mode_sel") || "normal";
  const savedTheme = lsGet(LS_THEME) || "dark";
  applyTheme(savedTheme);
  chapterSel.addEventListener("change", ()=>lsSet("aws_quiz_chapter_sel", chapterSel.value));
  modeSel.addEventListener("change", ()=>lsSet("aws_quiz_mode_sel", modeSel.value));
  if (themeSel){
    themeSel.value = lsGet(LS_THEME) || "dark";
    themeSel.addEventListener("change", ()=> applyTheme(themeSel.value));
  }

  // 折りたたみフィルタ：初期化＋サマリ更新
  initFilterPanel();
  updateFilterSummary();

  applyMode();
}
init();

</script>
</body>
</html>